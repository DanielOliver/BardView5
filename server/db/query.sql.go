// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"

	"github.com/lib/pq"
)

const userInsert = `-- name: UserInsert :execrows
INSERT INTO "user" as u (uid, "name", email, tags, created_by)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (email) DO NOTHING
`

type UserInsertParams struct {
	Uid       string        `db:"uid"`
	Name      string        `db:"name"`
	Email     string        `db:"email"`
	Tags      []string      `db:"tags"`
	CreatedBy sql.NullInt64 `db:"created_by"`
}

func (q *Queries) UserInsert(ctx context.Context, arg UserInsertParams) (int64, error) {
	result, err := q.exec(ctx, q.userInsertStmt, userInsert,
		arg.Uid,
		arg.Name,
		arg.Email,
		pq.Array(arg.Tags),
		arg.CreatedBy,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const usersFindByUid = `-- name: UsersFindByUid :many
SELECT DISTINCT u.id, u.uid, u.created_by, u.created_at, u.effective_date, u.end_date, u.is_active, u.email, u.name, u.tags
FROM role_assignment ra
         INNER JOIN role r on ra.role_id = r.id
         INNER JOIN role_permission rp on r.id = rp.role_id
         INNER JOIN "user" u on evaluate_access_user(rp.conditions, $1::bigint, u.id)
WHERE ra.user_id = $1::bigint
  AND rp.subject = 'user'
  AND rp.is_active = true
  AND ra.is_active = true
  AND r.is_active = true
  AND u.uid = $2
ORDER BY u.id
`

type UsersFindByUidParams struct {
	SessionID int64  `db:"session_id"`
	Uid       string `db:"uid"`
}

func (q *Queries) UsersFindByUid(ctx context.Context, arg UsersFindByUidParams) ([]User, error) {
	rows, err := q.query(ctx, q.usersFindByUidStmt, usersFindByUid, arg.SessionID, arg.Uid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Uid,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.EffectiveDate,
			&i.EndDate,
			&i.IsActive,
			&i.Email,
			&i.Name,
			pq.Array(&i.Tags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
