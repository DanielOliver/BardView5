// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const getAclBySubject = `-- name: GetAclBySubject :many
SELECT ra.user_id
     , rp.subject
     , rp.conditions
     , rp.action
     , rp.subject_id
     , r.name "role_name"
     , r.role_id
FROM "role_assignment" ra
         INNER JOIN "role" r on ra.role_id = r.role_id AND r.is_active = true
         INNER JOIN role_permission rp on r.role_id = rp.role_id AND rp.is_active = true
WHERE rp.subject = $1
  AND (rp.subject_id IS NULL
    OR rp.subject_id = $2)
  AND ra.user_id = $3
  AND ra.is_active = true
`

type GetAclBySubjectParams struct {
	Subject   string        `db:"subject"`
	SubjectID sql.NullInt64 `db:"subject_id"`
	UserID    int64         `db:"user_id"`
}

type GetAclBySubjectRow struct {
	UserID     int64           `db:"user_id"`
	Subject    string          `db:"subject"`
	Conditions json.RawMessage `db:"conditions"`
	Action     string          `db:"action"`
	SubjectID  sql.NullInt64   `db:"subject_id"`
	RoleName   string          `db:"role_name"`
	RoleID     int64           `db:"role_id"`
}

func (q *Queries) GetAclBySubject(ctx context.Context, arg GetAclBySubjectParams) ([]GetAclBySubjectRow, error) {
	rows, err := q.query(ctx, q.getAclBySubjectStmt, getAclBySubject, arg.Subject, arg.SubjectID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAclBySubjectRow{}
	for rows.Next() {
		var i GetAclBySubjectRow
		if err := rows.Scan(
			&i.UserID,
			&i.Subject,
			&i.Conditions,
			&i.Action,
			&i.SubjectID,
			&i.RoleName,
			&i.RoleID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inhabitantsFindByWorld = `-- name: InhabitantsFindByWorld :many
SELECT wm.inhabitant_id,
       m.monster_id,
       wm.world_id,
       m.name,
       m.tags,
       m.monster_type,
       m.alignment,
       m.size_category,
       m.milli_challenge_rating,
       m.languages,
       m.description,
       wm.user_tags,
       wm.system_tags
FROM "monster" m
         INNER JOIN "inhabitant" wm ON wm.monster_id = m.monster_id
WHERE wm.world_id = $1
ORDER BY wm.world_id, wm.monster_id
OFFSET $2 LIMIT $3
`

type InhabitantsFindByWorldParams struct {
	WorldID   int64 `db:"world_id"`
	RowOffset int32 `db:"row_offset"`
	RowLimit  int32 `db:"row_limit"`
}

type InhabitantsFindByWorldRow struct {
	InhabitantID         int64    `db:"inhabitant_id"`
	MonsterID            int64    `db:"monster_id"`
	WorldID              int64    `db:"world_id"`
	Name                 string   `db:"name"`
	Tags                 []string `db:"tags"`
	MonsterType          string   `db:"monster_type"`
	Alignment            string   `db:"alignment"`
	SizeCategory         string   `db:"size_category"`
	MilliChallengeRating int64    `db:"milli_challenge_rating"`
	Languages            []string `db:"languages"`
	Description          string   `db:"description"`
	UserTags             []string `db:"user_tags"`
	SystemTags           []string `db:"system_tags"`
}

func (q *Queries) InhabitantsFindByWorld(ctx context.Context, arg InhabitantsFindByWorldParams) ([]InhabitantsFindByWorldRow, error) {
	rows, err := q.query(ctx, q.inhabitantsFindByWorldStmt, inhabitantsFindByWorld, arg.WorldID, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InhabitantsFindByWorldRow{}
	for rows.Next() {
		var i InhabitantsFindByWorldRow
		if err := rows.Scan(
			&i.InhabitantID,
			&i.MonsterID,
			&i.WorldID,
			&i.Name,
			pq.Array(&i.Tags),
			&i.MonsterType,
			&i.Alignment,
			&i.SizeCategory,
			&i.MilliChallengeRating,
			pq.Array(&i.Languages),
			&i.Description,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const inhabitantsFindByWorldAndMonster = `-- name: InhabitantsFindByWorldAndMonster :many
SELECT wm.inhabitant_id,
       m.monster_id,
       wm.world_id,
       m.name,
       m.tags,
       m.monster_type,
       m.alignment,
       m.size_category,
       m.milli_challenge_rating,
       m.languages,
       m.description,
       wm.user_tags,
       wm.system_tags
FROM "monster" m
         INNER JOIN "inhabitant" wm ON wm.monster_id = m.monster_id
WHERE m.monster_id = $1
  AND wm.monster_id = $1
  AND wm.world_id = $2
`

type InhabitantsFindByWorldAndMonsterParams struct {
	MonsterID int64 `db:"monster_id"`
	WorldID   int64 `db:"world_id"`
}

type InhabitantsFindByWorldAndMonsterRow struct {
	InhabitantID         int64    `db:"inhabitant_id"`
	MonsterID            int64    `db:"monster_id"`
	WorldID              int64    `db:"world_id"`
	Name                 string   `db:"name"`
	Tags                 []string `db:"tags"`
	MonsterType          string   `db:"monster_type"`
	Alignment            string   `db:"alignment"`
	SizeCategory         string   `db:"size_category"`
	MilliChallengeRating int64    `db:"milli_challenge_rating"`
	Languages            []string `db:"languages"`
	Description          string   `db:"description"`
	UserTags             []string `db:"user_tags"`
	SystemTags           []string `db:"system_tags"`
}

func (q *Queries) InhabitantsFindByWorldAndMonster(ctx context.Context, arg InhabitantsFindByWorldAndMonsterParams) ([]InhabitantsFindByWorldAndMonsterRow, error) {
	rows, err := q.query(ctx, q.inhabitantsFindByWorldAndMonsterStmt, inhabitantsFindByWorldAndMonster, arg.MonsterID, arg.WorldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []InhabitantsFindByWorldAndMonsterRow{}
	for rows.Next() {
		var i InhabitantsFindByWorldAndMonsterRow
		if err := rows.Scan(
			&i.InhabitantID,
			&i.MonsterID,
			&i.WorldID,
			&i.Name,
			pq.Array(&i.Tags),
			&i.MonsterType,
			&i.Alignment,
			&i.SizeCategory,
			&i.MilliChallengeRating,
			pq.Array(&i.Languages),
			&i.Description,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const languageFindAll = `-- name: LanguageFindAll :many
SELECT language_id, created_by, created_at, version, name
FROM "language" l
`

func (q *Queries) LanguageFindAll(ctx context.Context) ([]Language, error) {
	rows, err := q.query(ctx, q.languageFindAllStmt, languageFindAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Language{}
	for rows.Next() {
		var i Language
		if err := rows.Scan(
			&i.LanguageID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const monsterFindById = `-- name: MonsterFindById :many
SELECT monster_id, created_by, created_at, version, first_world_id, name, tags, monster_type, alignment, size_category, milli_challenge_rating, languages, description
FROM "monster" m
WHERE m.monster_id = $1
`

func (q *Queries) MonsterFindById(ctx context.Context, monsterID int64) ([]Monster, error) {
	rows, err := q.query(ctx, q.monsterFindByIdStmt, monsterFindById, monsterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Monster{}
	for rows.Next() {
		var i Monster
		if err := rows.Scan(
			&i.MonsterID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.FirstWorldID,
			&i.Name,
			pq.Array(&i.Tags),
			&i.MonsterType,
			&i.Alignment,
			&i.SizeCategory,
			&i.MilliChallengeRating,
			pq.Array(&i.Languages),
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sizeCategoryFindAll = `-- name: SizeCategoryFindAll :many
SELECT created_by, created_at, version, name, space
FROM "size_category" s
`

func (q *Queries) SizeCategoryFindAll(ctx context.Context) ([]SizeCategory, error) {
	rows, err := q.query(ctx, q.sizeCategoryFindAllStmt, sizeCategoryFindAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SizeCategory{}
	for rows.Next() {
		var i SizeCategory
		if err := rows.Scan(
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.Name,
			&i.Space,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFindByEmail = `-- name: UserFindByEmail :many
SELECT user_id, uuid, created_by, created_at, version, effective_date, end_date, is_active, common_access, email, name, user_tags, system_tags
FROM "user" u
WHERE u.email = $1
`

func (q *Queries) UserFindByEmail(ctx context.Context, email string) ([]User, error) {
	rows, err := q.query(ctx, q.userFindByEmailStmt, userFindByEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uuid,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.EffectiveDate,
			&i.EndDate,
			&i.IsActive,
			&i.CommonAccess,
			&i.Email,
			&i.Name,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFindById = `-- name: UserFindById :many
SELECT user_id, uuid, created_by, created_at, version, effective_date, end_date, is_active, common_access, email, name, user_tags, system_tags
FROM "user" u
WHERE u.user_id = $1
`

func (q *Queries) UserFindById(ctx context.Context, userID int64) ([]User, error) {
	rows, err := q.query(ctx, q.userFindByIdStmt, userFindById, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uuid,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.EffectiveDate,
			&i.EndDate,
			&i.IsActive,
			&i.CommonAccess,
			&i.Email,
			&i.Name,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFindByUuid = `-- name: UserFindByUuid :many
SELECT user_id, uuid, created_by, created_at, version, effective_date, end_date, is_active, common_access, email, name, user_tags, system_tags
FROM "user" u
WHERE u.uuid = $1
`

func (q *Queries) UserFindByUuid(ctx context.Context, uuid uuid.UUID) ([]User, error) {
	rows, err := q.query(ctx, q.userFindByUuidStmt, userFindByUuid, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uuid,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.EffectiveDate,
			&i.EndDate,
			&i.IsActive,
			&i.CommonAccess,
			&i.Email,
			&i.Name,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userInsert = `-- name: UserInsert :execrows
INSERT INTO "user" as u (user_id, uuid, "name", email, user_tags, system_tags, created_by, common_access, is_active)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
ON CONFLICT (email) DO NOTHING
`

type UserInsertParams struct {
	UserID       int64         `db:"user_id"`
	Uuid         uuid.UUID     `db:"uuid"`
	Name         string        `db:"name"`
	Email        string        `db:"email"`
	UserTags     []string      `db:"user_tags"`
	SystemTags   []string      `db:"system_tags"`
	CreatedBy    sql.NullInt64 `db:"created_by"`
	CommonAccess string        `db:"common_access"`
	IsActive     bool          `db:"is_active"`
}

func (q *Queries) UserInsert(ctx context.Context, arg UserInsertParams) (int64, error) {
	result, err := q.exec(ctx, q.userInsertStmt, userInsert,
		arg.UserID,
		arg.Uuid,
		arg.Name,
		arg.Email,
		pq.Array(arg.UserTags),
		pq.Array(arg.SystemTags),
		arg.CreatedBy,
		arg.CommonAccess,
		arg.IsActive,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const userUpdate = `-- name: UserUpdate :many
UPDATE "user" as u
SET name          = $1
  , user_tags     = $2
  , system_tags   = $3
  , common_access = $4
  , version       = version + 1
  , is_active     = $5
WHERE u.user_id = $6
  AND u.version = $7 RETURNING user_id, uuid, created_by, created_at, version, effective_date, end_date, is_active, common_access, email, name, user_tags, system_tags
`

type UserUpdateParams struct {
	Name         string   `db:"name"`
	UserTags     []string `db:"user_tags"`
	SystemTags   []string `db:"system_tags"`
	CommonAccess string   `db:"common_access"`
	IsActive     bool     `db:"is_active"`
	UserID       int64    `db:"user_id"`
	Version      int64    `db:"version"`
}

func (q *Queries) UserUpdate(ctx context.Context, arg UserUpdateParams) ([]User, error) {
	rows, err := q.query(ctx, q.userUpdateStmt, userUpdate,
		arg.Name,
		pq.Array(arg.UserTags),
		pq.Array(arg.SystemTags),
		arg.CommonAccess,
		arg.IsActive,
		arg.UserID,
		arg.Version,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UserID,
			&i.Uuid,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.EffectiveDate,
			&i.EndDate,
			&i.IsActive,
			&i.CommonAccess,
			&i.Email,
			&i.Name,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const worldFindById = `-- name: WorldFindById :many
SELECT world_id, created_by, created_at, version, is_active, common_access, user_tags, system_tags, derived_from_world, name
FROM "world" w
WHERE w.world_id = $1
`

func (q *Queries) WorldFindById(ctx context.Context, worldID int64) ([]World, error) {
	rows, err := q.query(ctx, q.worldFindByIdStmt, worldFindById, worldID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []World{}
	for rows.Next() {
		var i World
		if err := rows.Scan(
			&i.WorldID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.Version,
			&i.IsActive,
			&i.CommonAccess,
			pq.Array(&i.UserTags),
			pq.Array(&i.SystemTags),
			&i.DerivedFromWorld,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const worldInsert = `-- name: WorldInsert :execrows
insert into "world" (world_id, derived_from_world, common_access, created_by, is_active, system_tags, user_tags,
                     "name")
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type WorldInsertParams struct {
	WorldID          int64         `db:"world_id"`
	DerivedFromWorld sql.NullInt64 `db:"derived_from_world"`
	CommonAccess     string        `db:"common_access"`
	CreatedBy        sql.NullInt64 `db:"created_by"`
	IsActive         bool          `db:"is_active"`
	SystemTags       []string      `db:"system_tags"`
	UserTags         []string      `db:"user_tags"`
	Name             string        `db:"name"`
}

func (q *Queries) WorldInsert(ctx context.Context, arg WorldInsertParams) (int64, error) {
	result, err := q.exec(ctx, q.worldInsertStmt, worldInsert,
		arg.WorldID,
		arg.DerivedFromWorld,
		arg.CommonAccess,
		arg.CreatedBy,
		arg.IsActive,
		pq.Array(arg.SystemTags),
		pq.Array(arg.UserTags),
		arg.Name,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
